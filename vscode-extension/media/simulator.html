<!DOCTYPE html>
<html>
<head>
  <style>
    * { box-sizing: border-box; }
    html { height: 100%; }
    body {
      margin: 0; padding: 8px;
      height: 100%;
      background: #1e1e1e; color: #ccc;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 12px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      grid-template-rows: 1fr;
      gap: 12px;
      height: calc(100% - 16px);
      overflow-y: auto;
    }
    .card {
      background: #2d2d2d; border-radius: 8px;
      overflow: hidden; display: flex; flex-direction: column;
      min-height: 0;
    }

    /* Centering wrapper — fills card, centers the device frame */
    .card .preview-container {
      flex: 1 1 0;
      min-height: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px 14px;
      overflow: hidden;
    }

    /* Device bezel — takes full height, shrink-wraps width to image */
    .card .device-frame {
      position: relative;
      height: 100%;
      max-width: 100%;
      padding: 6px;
      border-radius: 44px;
      background: linear-gradient(145deg, #4a4a4e 0%, #2a2a2c 40%, #3a3a3e 100%);
      box-shadow:
        0 0 0 1px #1a1a1c,
        0 4px 20px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.08);
      display: flex;
    }
    /* Volume buttons (left side) */
    .card .device-frame::before {
      content: '';
      position: absolute;
      left: -3px;
      top: 22%;
      width: 3px;
      height: 26px;
      background: linear-gradient(180deg, #48484a, #2c2c2e);
      border-radius: 2px 0 0 2px;
      box-shadow: 0 34px 0 #3a3a3c;
    }
    /* Power button (right side) */
    .card .device-frame::after {
      content: '';
      position: absolute;
      right: -3px;
      top: 18%;
      width: 3px;
      height: 44px;
      background: linear-gradient(180deg, #48484a, #2c2c2e);
      border-radius: 0 2px 2px 0;
    }

    /* Screen area — stretches to frame height, shrink-wraps width to image */
    .card .device-screen {
      position: relative;
      overflow: hidden;
      background: #000;
      border-radius: 38px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 200px;
      min-width: 120px;
    }

    .card img {
      display: block;
      width: auto;
      height: auto;
      max-height: 100%;
      max-width: 100%;
      user-select: none; -webkit-user-drag: none;
    }
    /* Status text shown while device frame is hidden (booting / building / error) */
    .card .status-overlay {
      display: flex; flex-direction: column; align-items: center; gap: 12px;
      color: #aaa; font-size: 14px;
    }
    .card .status-overlay .spinner {
      width: 28px; height: 28px;
      border: 3px solid #444;
      border-top-color: #aaa;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .card .card-info {
      padding: 8px 12px; display: flex; flex-direction: column; gap: 2px;
    }
    .card .device-name { font-weight: 600; color: #eee; }
    .card .file-name { color: #888; font-size: 11px; }
    .card .card-actions {
      padding: 4px 12px 8px; display: flex; gap: 8px;
    }
    .card .card-actions button {
      background: #3c3c3c; border: none; color: #ccc;
      padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 11px;
    }
    .card .card-actions button:hover { background: #4c4c4c; }
    .card .card-actions .btn-remove { margin-left: auto; color: #e88; }
  </style>
</head>
<body>
  <div class="grid" id="grid"></div>

  <template id="card-template">
    <div class="card">
      <div class="preview-container">
        <div class="status-overlay"><div class="spinner"></div><span class="status-text">Initializing...</span></div>
        <div class="device-frame" style="display:none">
          <div class="device-screen">
            <img class="preview-image" />
          </div>
        </div>
      </div>
      <div class="card-info">
        <span class="device-name"></span>
        <span class="file-name"></span>
      </div>
      <div class="card-actions">
        <button class="btn-device">Device</button>
        <!-- Hidden by default; shown via showNextButton message when previewCount > 1. -->
        <button class="btn-next" style="display:none">Next</button>
        <button class="btn-remove">&times;</button>
      </div>
    </div>
  </template>

  <script>
    const vscode = acquireVsCodeApi();
    const grid = document.getElementById('grid');
    const cardTemplate = document.getElementById('card-template');

    // Track per-card drag state.
    const dragStates = {};

    /** Find a card element by streamId, optionally narrowing to a child selector. */
    function queryCard(streamId, childSelector) {
      const selector = '[data-stream-id="' + streamId + '"]'
        + (childSelector ? ' ' + childSelector : '');
      return document.querySelector(selector);
    }

    /** Convert a mouse event to normalised [0..1] coordinates relative to an element. */
    function normalizedCoords(e, el) {
      const rect = el.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) / rect.width,
        y: (e.clientY - rect.top) / rect.height,
      };
    }

    /** Same as normalizedCoords but clamps to [0, 1]. */
    function clampedCoords(e, el) {
      const { x, y } = normalizedCoords(e, el);
      return {
        x: Math.max(0, Math.min(1, x)),
        y: Math.max(0, Math.min(1, y)),
      };
    }

    window.addEventListener('message', (e) => {
      const msg = e.data;
      switch (msg.type) {
        case 'addCard': {
          if (queryCard(msg.streamId)) return;
          const card = cardTemplate.content.cloneNode(true).firstElementChild;
          card.dataset.streamId = msg.streamId;
          card.querySelector('.device-name').textContent = msg.deviceName || '';
          card.querySelector('.file-name').textContent = msg.fileName || '';
          grid.appendChild(card);
          setupCardEvents(card, msg.streamId);
          break;
        }
        case 'removeCard': {
          const el = queryCard(msg.streamId);
          if (el) el.remove();
          delete dragStates[msg.streamId];
          break;
        }
        case 'frame': {
          const img = queryCard(msg.streamId, '.preview-image');
          if (img) {
            img.src = 'data:image/jpeg;base64,' + msg.data;
            const frame = queryCard(msg.streamId, '.device-frame');
            if (frame) frame.style.display = '';
            const overlay = queryCard(msg.streamId, '.status-overlay');
            if (overlay) overlay.style.display = 'none';
          }
          break;
        }
        case 'status': {
          const frame = queryCard(msg.streamId, '.device-frame');
          if (frame) frame.style.display = 'none';
          const text = queryCard(msg.streamId, '.status-text');
          if (text) text.textContent = msg.phase;
          const overlay = queryCard(msg.streamId, '.status-overlay');
          if (overlay) overlay.style.display = '';
          break;
        }
        case 'showNextButton': {
          const btn = queryCard(msg.streamId, '.btn-next');
          if (btn) btn.style.display = '';
          break;
        }
      }
    });

    function setupCardEvents(card, streamId) {
      const img = card.querySelector('.preview-image');

      // Touch events with streamId.
      img.addEventListener('mousedown', (e) => {
        e.preventDefault();
        dragStates[streamId] = { moveScheduled: false };
        const { x, y } = normalizedCoords(e, img);
        vscode.postMessage({ type: 'touchDown', streamId, x, y });
      });
      img.addEventListener('mousemove', (e) => {
        const state = dragStates[streamId];
        if (!state || state.moveScheduled) return;
        state.moveScheduled = true;
        const { x, y } = normalizedCoords(e, img);
        requestAnimationFrame(() => {
          vscode.postMessage({ type: 'touchMove', streamId, x, y });
          state.moveScheduled = false;
        });
      });
      img.addEventListener('mouseup', (e) => {
        if (!dragStates[streamId]) return;
        const { x, y } = normalizedCoords(e, img);
        vscode.postMessage({ type: 'touchUp', streamId, x, y });
        delete dragStates[streamId];
      });
      img.addEventListener('mouseleave', (e) => {
        if (!dragStates[streamId]) return;
        const { x, y } = clampedCoords(e, img);
        vscode.postMessage({ type: 'touchUp', streamId, x, y });
        delete dragStates[streamId];
      });

      // Action buttons.
      card.querySelector('.btn-remove').addEventListener('click', () => {
        vscode.postMessage({ type: 'removeStream', streamId });
      });
      card.querySelector('.btn-device').addEventListener('click', () => {
        vscode.postMessage({ type: 'changeDevice', streamId });
      });
      card.querySelector('.btn-next').addEventListener('click', () => {
        vscode.postMessage({ type: 'nextPreview', streamId });
      });
    }

    // Global keypress → send to all cards.
    // Future improvement: track which card has focus and send input only to that card.
    // Currently broadcasts to all streams because per-card focus management is out of scope.
    document.addEventListener('keypress', (e) => {
      if (e.key.length === 1) {
        const cards = document.querySelectorAll('.card');
        cards.forEach(card => {
          vscode.postMessage({ type: 'text', streamId: card.dataset.streamId, value: e.key });
        });
      }
    });
  </script>
</body>
</html>
